namespace SharpNeedle.Numerics;

// I have no idea if anything in this struct is valid, this was entirely generated by Github Copilot
public struct Ray : IIntersectable<Sphere>, IIntersectable<AABB>
{
    public Vector3 Origin;
    public Vector3 Direction;

    public Ray(Vector3 origin, Vector3 direction)
    {
        Origin = origin;
        Direction = direction;
    }
    
    public Vector3? Intersection(AABB aabb)
    {
        var tmin = Vector3.Dot(aabb.Min - Origin, Direction);
        var tmax = Vector3.Dot(aabb.Max - Origin, Direction);
        var t1 = Math.Min(tmin, tmax);
        var t2 = Math.Max(tmin, tmax);
        if (t1 > 0 && t2 > 0)
            return Origin + Direction * t1;

        return null;
    }

    public Vector3? Intersection(Sphere sphere)
    {
        var a = Vector3.Dot(Direction, Direction);
        var b = 2 * Vector3.Dot(Direction, Origin - sphere.Center);
        var c = Vector3.Dot(Origin - sphere.Center, Origin - sphere.Center) - sphere.Radius * sphere.Radius;

        var discriminant = b * b - 4 * a * c;

        if (discriminant < 0)
            return null;

        var t = (-b - MathF.Sqrt(discriminant)) / (2 * a);

        return Origin + Direction * t;
    }

    public bool Intersects(Sphere sphere)
    {
        var a = Vector3.Dot(Direction, Direction);
        var b = 2 * Vector3.Dot(Direction, Origin - sphere.Center);
        var c = Vector3.Dot(Origin - sphere.Center, Origin - sphere.Center) - sphere.Radius * sphere.Radius;

        var discriminant = b * b - 4 * a * c;

        return discriminant >= 0;
    }

    public bool Intersects(AABB aabb)
    {
        var tmin = Vector3.Dot(aabb.Min - Origin, Direction) / Vector3.Dot(Direction, Direction);
        var tmax = Vector3.Dot(aabb.Max - Origin, Direction) / Vector3.Dot(Direction, Direction);

        if (tmin > tmax)
            (tmin, tmax) = (tmax, tmin);

        return tmin <= tmax;
    }

    public Vector3 PointAt(float t)
    {
        return Origin + t * Direction;
    }
}